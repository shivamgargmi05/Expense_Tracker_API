package com.garg.config;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.garg.filter.JwtRequestFilter;
import com.garg.service.CustomUserDetailsService;

/* As by default, after addding Spring Security dependency, all rest endpoints become protected that needs authentication but some 
   endpoints like login user/creating new user needs no authentication that should be accessible publicly/by anyone. So, customizing 
   Spring Security default configuration. 
   
   Spring Security Control Flow - back & forth, client request ->
   1. Authentication Filter(Security Context) -
   		It uses SecurityContext to check whether the user is logged in(authenticated) or not for each request.
   		If user is logged in, don't authenticate existing user again for new requests but if not logged in, then authenticate for the 1st request.
   2. Authentication Manager - uses Authentication Type i.e., inMemory/JDBC/LDAP only for first time
   3. Authentication Provider(UserDetailsService & PasswordEncoder) - (Authenticate User)Verifies username & password to login

	as username & password are hardcoded for inMemory Authentication but customize UserDetailsService to validate username & password
	from db.
	Use Spring Security in Service layer
		A CustomUserDetailsService class that extends UserDetailsService, override UserDetails loadUserByUsername(); 
		with findByEmail() in User repository & autowired in SecurityConfiguration class.
		
	Spring Security without the WebSecurityConfigurerAdapter class - 
https://spring.io/blog/2022/02/21/spring-security-without-the-websecurityconfigureradapter/

Create a Spring Security configuration class with SecurityFilterChain Bean & DaoAuthenticationProvider Bean
*/

@Configuration
public class SecurityConfiguration {

	// Step 4. Register the JWT filter with Spring Security Config file i.e., modify SecurityFilterChain Bean
	//		To tell Spring Security to validate jwt token for all http request to endpoints 
	@Bean
	public JwtRequestFilter authenticationJwtTokenFilter() {
		return new JwtRequestFilter();
	}
	
	// 1. Create SecurityFilterChain Bean - for mentioning public(no auth) & protected(auth) Http Request rest endpoints
	@Bean
	public SecurityFilterChain createSecurityFilterChainBean(HttpSecurity http) throws Exception {
		http
			.csrf().disable()
			.authorizeHttpRequests()
			.requestMatchers("/login", "/register").permitAll()
			.anyRequest().authenticated()
			.and()
			.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);	// tell not to use session JSessionID, use jwt 
		
		http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);
			
		http.httpBasic();	// for login using Postman/Microservices	
		
		//	http.formLogin();	for form based login in webapp
		
		return http.build();
	}

	@Autowired
	private CustomUserDetailsService userDetailsService;
	
	// 2. Create DaoAuthenticationProvider Bean - to customize user default login inMemory authentication info(username - user & password generated by spring boot)/multiple user login info 
	@Bean
	public DaoAuthenticationProvider createAuthenticationProviderBean() {
		/* User login details are hardcoded but validating user login details from db using CustomUserDetailsService Bean
		  // without user role & password encoding, spring gives exception
		UserDetails user1=User.withDefaultPasswordEncoder().username("Shivam Garg").password("11111").authorities("ADMIN").build();
		UserDetails user2=User.withDefaultPasswordEncoder().username("Harsh Garg").password("22222").authorities("USER").build();
		
		InMemoryUserDetailsManager userDetails=new InMemoryUserDetailsManager(user1, user2);
		*/
		
		DaoAuthenticationProvider authenticationProvider=new DaoAuthenticationProvider();
		
		authenticationProvider.setUserDetailsService(userDetailsService); 
		authenticationProvider.setPasswordEncoder(createPasswordEncoderBean());
		
		return authenticationProvider;
	}
	
	@Bean
	public PasswordEncoder createPasswordEncoderBean() {
		return new BCryptPasswordEncoder();
	}

	@Bean
	protected AuthenticationManager createAuthenticationManagerBean(AuthenticationConfiguration configuration) throws Exception {
		return configuration.getAuthenticationManager();
	}
	
}
